;---------------------------------------------
Memory map:
;---------------------------------------------

0000H - 1FFFH	BIOS ROM
2000H - 3FFFH	Expansion port
	3000H	Stack downwards
4000H - 5FFFH	Expansion port
6000H - 7FFFH	Start of RAM (1K mapped into an 8K spot)
8000H - FFFFH	Cart ROM (broken into 4 sections, each enabled seperately)

;---------------------------------------------
I/O:
;---------------------------------------------

00-1F - No Connection
20-3F - No Connection
40-5F - Video
60-7F - Video
80-9F - No Connection
A0-BF - No Connection
C0-DF - Sound
E0-FF - Controllers; E2 is special, as wellas E0
	 - E0 appears to be the readback, and E2 appears to be the scan - 39

;---------------------------------------------
VDU registers:
;---------------------------------------------

NOTE:

-bit 0 is MSB (ie: 0 1 2 3 4 5 6 7, 0=128 and 7=1)
-"enables" are active when set to 1
-">" represents a hexadecimal number (ie: >400 = 400 hex)

Register 0	- Bits 0-5 - Reserved, set to 000000
		  Bit 6	   - Mode bit 3 (M3) - sets bitmap mode
		  Bit 7	   - Enable external video source
				 (replaces color 1 (transparent))
Register 1	- Bit 0	   - 4/16k switch, if set, uses 16k
		  Bit 1	   - blank enable (blanks display)
		  Bit 2	   - Interrupt enable
		  Bit 3	   - Mode bit 1 (M1) - sets text mode
		  Bit 4	   - Mode bit 2 (M2) - sets multicolor mode
		  Bit 5	   - reserved - set to 0
		  Bit 6	   - sprite size
				 - 0=normal (8x8), 1=large (16x16)
		  Bit 7	   - sprite magnification enable
Register 2	  Base address of the Screen Image Table.
			Multiply this value by >400
Register 3	  Base address of the Color Table.
			Multiply this value by >400
Register 4	  Base address of the Pattern Descriptor Table.
			Multiply this value by >800
Register 5	  Base address of the Sprite Attribute List.
			Multiply this value by >80
Register 6	  Base address of the Sprite Descriptor Table.
			Multiply this value by >800
Register 7	- Bits 0-3 - Foreground color in Text mode only
		  Bits 4-7 - Background color in all modes

The mode bits, M1, M2 and M3 determine the mode of the display. 
If they are all 0, the display is in Graphics mode. 
Else as listed above. 
Below the various modes are explained.

;---------------------------------------------
Graphic modes:
;---------------------------------------------

Graphics mode uses an array of 32 columns by 24 lines. 
Each position may have one of the 256 patterns in the pattern table 
(usually including ASCII characters). 
Foreground and background colors may be set for the characters, 
and sprites are available.

;---------------------------------------------
Screen image table
;---------------------------------------------

This specifies which character occupies each position on the screen. 
It is 768 bytes long. 
Whatever byte is at each position is what appears at that location.

To calculate an address from X and Y, 
use (Y*32)+X (or (Y<<5)+x) and add the base address.

;---------------------------------------------
MULTICOLOR MODE
;---------------------------------------------
 
In multicolor mode, the screen is 48 rows, and 64 columns wide, 
with each 'box' being 4 pixels by 4 pixels. 
There are thus 3072 boxes, each of which can be a different color with no restrictions. 
Sprites are available.

The general way to set up is like so:

SCREEN IMAGE TABLE

Initialize the Screen Image Table so that the 
first >80 bytes contain >00 through >1F repeated 4 times, 
the next >80 bytes contain >20 through >3F repeated 4 times, 
and so on, 
so that the last >80 bytes contain >A0 through >BF repeated 4 times.

PATTERN DESCRIPTOR TABLE

The pattern descriptor table now contains colors, instead of patterns. 
They are still organized in 8-character blocks, 
with each byte describing the colors of two boxes. 
The high nibble is the first block, and the low nibble is the block to it's right.

The first byte defines the first two blocks in row 1. 
The second byte is the first two blocks in row 2. 
This continues until the eighth byte (the first two blocks in row 8), 
and then goes back to row one. 
This continues until the first 32 eight-byte segments have been defined, 
describing all the blocks in the first 8 rows.

It's very messy... but draw yourself a picture and it should make sense.

Essentially, each entry in the screen image table still points to an 8-byte 'definition', 
but the definition defines the colours, not the pixels, now, 
making each character a 2x8 colored group. :) 
Initializing the screen image table as above lets you change 
the screen by editing the pattern descriptor table, but it's not the only way. :)

;---------------------------------------------
BITMAP MODE
;---------------------------------------------
 
Bitmap mode allows independantly defining each of the 768 screen positions, 
and allows a bit more color freedom as well. 
Sprites are also allowed. As normal, 
the patterns for each position are in the Screen Image Table, 
the descriptions are in the Pattern Descriptor Table, 
and the colors are in the Color Table.

SCREEN IMAGE TABLE

As before, each entry is a single byte from >00 to >FF defining which pattern 
to place at each location. 
In bitmap mode, however, it is divided into 3 sections of 256 bytes each, 
each pointing essentially to a different character set. 
The first section uses the first 256 entries in the pattern and color table, 
the second section uses the next 256 entries, 
and the third uses the last 256 entries. 
Normally this table is set at >1800 (assuming 16k VDP ram) (VDP register 2 = >06)

PATTERN DESCRIPTOR TABLE
It works the same as in graphics mode, except that there are now 3 sections, 
each 256 patterns long, allowing 768 possible patterns. It's size is 6144 bytes.

The first section is for the first third of the screen, and so on.

It should normally be placed at either >0000 or >2000 (VDP register 4 = >00 or >04). 
The color table will sit at the other address.

COLOR TABLE

The color table works much like it did in graphics mode, 
except that each entry now defines a single character, 
and every row of that character has it's own color entry. 
It matches byte-for-byte the entries in the pattern descriptor table, 
with the high nibble being the foreground colour, 
and the low nibble being the background color for that row of the pattern.

It is also divided into three 256 character sections, 
and each entry is also 8 bytes long. 
It is 6144 bytes long, 
and should be placed at either >0000 or >2000, 
whichever the PDT is not at. (VDP register 3 = >00 or >04).

DISCUSSION of bitmap mode

For using bitmap mode, it is usually easiest (but not fastest!) to initialize 
the Screen Image Table with >00 through >FF three times, 
and then alter the entries in the Pattern Descriptor table and Color table.

Thus, to alter a pixel on the screen, 
you must calculate the byte and bit to be changed in the pattern descriptor table. 
The same offset will let you alter the color table.

I don't know what processor the Coleco uses, 
but here is a psuedo code for a weird and wacky formula that will calculate 
the byte offset and bit offset of a given coordinate, 
ready to be indexed into the appropriate table. :) 
Note this is all 16-bit math. 
Don't ask me why it works, but it does seem to. :)

XIn = X coordinate 0-255
YIn = Y coordinate 0-191
ByteOut = Byte Offset into tables
BitOut = Bit offset into byte in pattern descriptor table

1. Copy YIn to ByteOut
2. Shift ByteOut left 5 times (ie: multiply by 32)
3. OR YIn into ByteOut
4. AND ByteOut with >FF07
5. Copy XIn to BitOut
6. AND Bitout with >0007
7. Add XIn to ByteOut
8. Subtract BitOut from ByteOut

;---------------------------------------------
SPRITES
;---------------------------------------------
 
Sprites are independant of the screen and their patterns can be in addition 
to those in the pattern descriptor table 
(or the sprite descriptor table can be set up to overlap). 
There can be up to 32 sprites and there are 4 available sizes.

SPRITE ATTRIBUTE LIST

This list defines the position and color of each of the 32 sprites, 0-31. 
To move a sprite, you must update the entries in this table. 
Sprites may be located at any visible position (0- 255 and 0-191), 
or off the bottom of the screen (y> 191).

Each definition is 4 bytes long, thus the table is 128 bytes long. 
The first row on the screen is >FF, 
the next is >00 and so on to >BE. (so it says!) :)

Byte 1	- Y position of the sprite. 
		>D0 means end ofthe sprite list, 
		 so be aware if allowing sprites off the bottom.
Byte 2	- X position of the sprite. 
		>00 - >FF
Byte 3	- pattern of the sprite, from 
		>00 to >FF, in the SPRITE Descriptor Table
Byte 4	Bits 0-2	= apparently undefined
 	Bit 3		= Early clock attribute - Normally, 
			  the coordinates indicate the top left corner of the sprite, 
			  and sprites can scroll smoothly off the right side of the screen. 
			  If this bit is set, the early clock is enabled, 
			  and the sprite is shifted 32 pixels to the left, 
			  and scrolls smoothly off the left of the screen.
 	Bits 4-7	= Sprite color

SPRITE DESCRIPTOR TABLE

This table is defined exactly the same way as the pattern descriptor table in graphics mode. 
However, sprites can be double-sized or magnified. 
A magnified sprite simply has each pixel twice it's normal size. 
A double-size sprite uses four consecutive characters, laid out like this:

1 3
2 4

Sprites thus range from 8x8 pixels to 32x32 pixels, but only 16x16 pixels of detail.

;---------------------------------------------
Colors:
;---------------------------------------------

This table contains the foreground and background colors of all the characters. 
The high nibble is the foreground color, 
and the low nibble is the background color. 
Each byte represents a group of 8 characters 
(ie: the first entry is for characters 0-7, 
the second for characters 8-15, etc). 
The table is 32 bytes long.

The colors are: (in hex)
0 = Transparent
1 = Black
2 = Medium Green
3 = Light Green
4 = Dark Blue
5 = Light Blue
6 = Dark Red
7 = Cyan
8 = Medium Red
9 = Light Red
A = Dark Yellow
B = Light Yellow
C = Dark Green
D = Magenta
E = Gray
F = White

